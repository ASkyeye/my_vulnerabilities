
# CVE-2020-0871 Writeup

---

***Acknowledgements: https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2020-0871***

This is an out-of-bound read information disclosure in Network Connection Service

### Issue code

---

***Before patch***

```
__int64 __fastcall CLanConnection::Save(CLanConnection *this, unsigned __int8 *a2, unsigned int a3)
{
  if ( a2 )
  {
    if ( *((_DWORD *)this + 0x50) && *((_QWORD *)this + 0x58) )
    {
      v5 = HrGetInstanceGuid(*((void **)this + 11), (const struct _SP_DEVINFO_DATA *)this + 3, (struct _GUID *)&Src);
      if ( !v5 )
      {
        memcpy_0(a2, &Src, a3);
        return v5;
      }
    }
    else
    {
      v5 = -2147418113;
    }
    if ( (v5 & 0x80000000) == 0 )
      return v5;
  }
}
```

### Detail

---

The vulnerability existed in netman.dll, method Save() invoke memcpy to copy instance GUID to the buffer which created by user. But service not check the copy size which also can be controlled by normal user.

So I can set size to a large value which will trigger out-of-bound read.

But there is a check before invoke HrGetInstanceGuid(), service will check variable this+0x50 and this+0x58 if these two value is zero. When I debug it, I found the default value is zero, so I do some reverse to find out how to set it.

I found there is another method named HrLoad(), it will set these two value.

```
__int64 __fastcall CLanConnection::HrLoad(CLanConnection *this, const struct _GUID *a2)
{
  v3 = this;
  ...
  v5 = HrOpenConnectionKey(v2, 0i64, 0x2001Fu, 0, v8, (HKEY *)v3 + 0x50);//set this+0x50
  if ( (v5 & 0x80000000) == 0 )
    goto LABEL_6;
  v6 = (void **)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 28) & 1 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_4a374b92804e35b1e03f42086d0e7d48_Traceguids, v5);
LABEL_6:
    v6 = (void **)WPP_GLOBAL_Control;
  }
  if ( (v5 & 0x80000000) == 0 )
  {
    *((_DWORD *)v3 + 0x58) = 1;set this+0x58
    return v5;
  }
}
```

So if function HrOpenConnectionKey() succeed, this+0x50 and this+0x58 will set the right value, I need to use a right GUID to make it work.

```
signed __int64 __fastcall HrOpenConnectionKey(GUID *a1, char *a2, unsigned int a3, char a4, __int64 a5, HKEY *a6)
{
    ...
    if ( a1 )
    {
      StringFromGUID2(a1, (LPOLESTR)Dst, 39);
      v7 = Dst;
    }
    StringCchPrintfW(
    &Dest,
    0x100ui64,
    L"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\%s\\Connection",
    v7);
    if ( v9 & 1 )
    {
    v10 = HrRegCreateKeyEx(v12, &Dest, v13, v6, (struct _SECURITY_ATTRIBUTES *)ppv, a6, (unsigned int *)&v21.Data4[4]);
    ...
    }
    ...
}
```

***After patch***

```
__int64 __fastcall CLanConnection::Save(CLanConnection *this, unsigned __int8 *a2, unsigned int a3)
{
  ...
  v6 = a3;
  if ( (unsigned int)a3 > 0x10 )
    v6 = 0x10i64;
  memcpy_0(a2, &Src, v6);
  return v5;
}
```

### Crash Dump

---

```
0:002> r
rax=0000015b01465040 rbx=0000000000000000 rcx=0000015b01467090
rdx=fffffebbdf998f50 rsi=000000000000ffff rdi=0000015b01465040
rip=00007ffbac7144c9 rsp=00000016e0dfdf68 rbp=00000016e0dfdff0
 r8=000000000000002f  r9=000000000000037e r10=0000000000000000
r11=00000016e0e0df8f r12=00000016e0dfe480 r13=00007ffb85a203e0
r14=0000000000000000 r15=0000015b0143d820
iopl=0         nv up ei pl nz na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
msvcrt!memcpy+0x109:
00007ffb`ac7144c9 0f105c1120      movups  xmm3,xmmword ptr [rcx+rdx+20h] ds:00000016`e0e00000=????????????????????????????????
```

### Stack Trace

---

```
Stack trace:
0:002> k
Child-SP          RetAddr           Call Site
00000016`e0dfdf68 00007ffb`884fc83e msvcrt!memcpy+0x109
00000016`e0dfdf70 00007ffb`ac352033 netman!CLanConnection::Save+0x5e
00000016`e0dfdfd0 00007ffb`ac3bb1d3 RPCRT4!NdrSendReceive+0x3d3
00000016`e0dfe030 00007ffb`ac2fb3f9 RPCRT4!Ndr64AsyncServerCallAll+0x1f93
```

### Time Line

---

***Dec 2019:*** Vulnerability Reported
***Jan 2020:*** Microsoft Reproduced
***Feb 2020:*** Bounty Awarded
***Mar 2020:*** Patch Released
